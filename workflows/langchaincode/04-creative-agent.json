{
  "name": "Creative Agent",
  "nodes": [
    {
      "parameters": {
        "queue": "creative_tasks",
        "options": {}
      },
      "id": "rabbitmq-consume",
      "name": "RabbitMQ Consumer",
      "type": "n8n-nodes-base.rabbitmqTrigger",
      "typeVersion": 1,
      "position": [160, 304]
    },
    {
      "parameters": {
        "jsCode": "// Creative Agent - Production Implementation\nconst { ChatOpenAI } = require(\"@langchain/openai\");\nconst { AgentExecutor, createOpenAIFunctionsAgent } = require(\"langchain/agents\");\nconst { DynamicTool } = require(\"@langchain/core/tools\");\nconst { PromptTemplate } = require(\"@langchain/core/prompts\");\n\n// Initialize LangSmith tracing\nprocess.env.LANGCHAIN_TRACING_V2 = \"true\";\nprocess.env.LANGCHAIN_PROJECT = process.env.LANGCHAIN_PROJECT || \"athenai-creative-agent\";\nprocess.env.LANGCHAIN_ENDPOINT = process.env.LANGCHAIN_ENDPOINT || \"https://api.smith.langchain.com\";\n\nasync function executeCreativeAgent() {\n  try {\n    const inputData = $json;\n    const taskData = inputData.analysis_report || inputData.research_report || inputData.task || inputData;\n    const analysisData = taskData.analysis || {};\n    const researchData = taskData.findings || {};\n    const query = taskData.query || taskData.original_message;\n    const sessionId = taskData.session_id || 'default_session';\n    const orchestrationId = taskData.orchestration_id || 'default_orchestration';\n    \n    if (!query) {\n      throw new Error('Query is required for creative synthesis');\n    }\n\n    // Initialize OpenAI\n    const llm = new ChatOpenAI({\n      modelName: \"gpt-4\",\n      temperature: 0.7,\n      openAIApiKey: $credentials.openAi?.apiKey || process.env.OPENAI_API_KEY,\n      tags: [\"creative-agent\", \"athenai\"]\n    });\n\n    // Initialize creative tools\n    const tools = await initializeCreativeTools();\n\n    // Create creative synthesis prompt\n    const creativePrompt = PromptTemplate.fromTemplate(`\nYou are a Creative Agent specialized in synthesizing information into engaging, comprehensive responses.\n\nResearch Data: {researchData}\nAnalysis Data: {analysisData}\nOriginal Query: {query}\nSession ID: {sessionId}\n\nYour task:\n1. Synthesize research and analysis into a cohesive narrative\n2. Create engaging, well-structured content\n3. Ensure accuracy while maintaining readability\n4. Provide actionable insights and recommendations\n5. Adapt tone and style to the context\n6. Include relevant examples and analogies\n\nCreate a comprehensive response that:\n- Addresses the original query directly\n- Incorporates key findings from research and analysis\n- Provides clear structure and flow\n- Includes actionable recommendations\n- Maintains appropriate tone and style\n- Cites sources where relevant\n\nQuery: {query}\n`);\n\n    // Create agent\n    const agent = await createOpenAIFunctionsAgent({\n      llm,\n      tools,\n      prompt: creativePrompt\n    });\n\n    const agentExecutor = new AgentExecutor({\n      agent,\n      tools,\n      verbose: true,\n      maxIterations: 6\n    });\n\n    // Execute creative synthesis\n    const creativeResult = await agentExecutor.invoke({\n      researchData: JSON.stringify(researchData, null, 2),\n      analysisData: JSON.stringify(analysisData, null, 2),\n      query: query,\n      sessionId: sessionId\n    });\n\n    // Process and enhance the creative output\n    const enhancedContent = await enhanceCreativeOutput(creativeResult, query, researchData, analysisData);\n    const contentMetrics = calculateContentMetrics(enhancedContent);\n\n    // Create creative report\n    const creativeReport = {\n      orchestration_id: orchestrationId,\n      session_id: sessionId,\n      agent_type: \"creative\",\n      query: query,\n      input_research: researchData,\n      input_analysis: analysisData,\n      creative_output: enhancedContent,\n      metrics: contentMetrics,\n      quality_score: calculateQualityScore(enhancedContent),\n      timestamp: new Date().toISOString(),\n      status: \"completed\"\n    };\n\n    return [{\n      json: {\n        creative_report: creativeReport,\n        final_response: enhancedContent.final_response,\n        next_actions: determineCreativeNextActions(enhancedContent),\n        neo4j_context: {\n          write: true,\n          cypher: `MERGE (s:Session {id: '${sessionId}'}) MERGE (o:Orchestration {id: '${orchestrationId}'}) MERGE (c:CreativeResponse {id: '${generateCreativeId()}', query: '${query.replace(/'/g, \"\\\\'\"))}', timestamp: datetime(), quality: ${creativeReport.quality_score}}) MERGE (s)-[:HAS_ORCHESTRATION]->(o) MERGE (o)-[:GENERATED_RESPONSE]->(c)`\n        },\n        memory: {\n          upsert: true,\n          keys: [\"query\", \"final_response\", \"quality_score\", \"timestamp\"]\n        },\n        routing: {\n          queue: \"response_delivery\",\n          priority: \"high\"\n        }\n      }\n    }];\n\n  } catch (error) {\n    return [{\n      json: {\n        error: error.message,\n        agent_type: \"creative\",\n        status: \"failed\",\n        timestamp: new Date().toISOString(),\n        fallback_response: \"I apologize, but I encountered an error while processing your request. Please try again or contact support if the issue persists.\"\n      }\n    }];\n  }\n}\n\n// Initialize creative tools\nasync function initializeCreativeTools() {\n  return [\n    new DynamicTool({\n      name: \"content_structurer\",\n      description: \"Structure content with proper headings, sections, and flow\",\n      func: async (content) => {\n        try {\n          const structured = structureContent(content);\n          return JSON.stringify(structured, null, 2);\n        } catch (error) {\n          return `Content structuring error: ${error.message}`;\n        }\n      }\n    }),\n    new DynamicTool({\n      name: \"tone_adapter\",\n      description: \"Adapt content tone and style for different audiences\",\n      func: async (input) => {\n        try {\n          const { content, targetAudience } = JSON.parse(input);\n          const adapted = adaptTone(content, targetAudience);\n          return adapted;\n        } catch (error) {\n          return `Tone adaptation error: ${error.message}`;\n        }\n      }\n    }),\n    new DynamicTool({\n      name: \"example_generator\",\n      description: \"Generate relevant examples and analogies\",\n      func: async (topic) => {\n        try {\n          const examples = generateExamples(topic);\n          return JSON.stringify(examples, null, 2);\n        } catch (error) {\n          return `Example generation error: ${error.message}`;\n        }\n      }\n    }),\n    new DynamicTool({\n      name: \"citation_formatter\",\n      description: \"Format citations and references properly\",\n      func: async (sources) => {\n        try {\n          const citations = formatCitations(JSON.parse(sources));\n          return citations;\n        } catch (error) {\n          return `Citation formatting error: ${error.message}`;\n        }\n      }\n    })\n  ];\n}\n\n// Enhance creative output\nasync function enhanceCreativeOutput(creativeResult, query, researchData, analysisData) {\n  const baseContent = creativeResult.output || \"\";\n  \n  return {\n    final_response: baseContent,\n    structure: analyzeContentStructure(baseContent),\n    key_points: extractKeyPoints(baseContent),\n    recommendations: extractRecommendations(baseContent),\n    sources_cited: extractCitedSources(baseContent, researchData),\n    readability: assessReadability(baseContent),\n    completeness: assessCompleteness(baseContent, query),\n    engagement_elements: identifyEngagementElements(baseContent)\n  };\n}\n\n// Content processing functions\nfunction structureContent(content) {\n  const sections = content.split('\\n\\n');\n  return {\n    introduction: sections[0] || \"\",\n    main_content: sections.slice(1, -1).join('\\n\\n'),\n    conclusion: sections[sections.length - 1] || \"\",\n    section_count: sections.length,\n    has_clear_structure: sections.length > 2\n  };\n}\n\nfunction adaptTone(content, audience = \"general\") {\n  const toneMap = {\n    technical: \"Use precise terminology and detailed explanations\",\n    business: \"Focus on practical implications and ROI\",\n    academic: \"Include theoretical framework and citations\",\n    general: \"Use accessible language and clear examples\"\n  };\n  \n  return `Adapted for ${audience} audience: ${content}`;\n}\n\nfunction generateExamples(topic) {\n  return {\n    analogies: [`Like ${topic} in everyday life...`],\n    case_studies: [`Real-world example of ${topic}...`],\n    scenarios: [`Imagine if ${topic}...`]\n  };\n}\n\nfunction formatCitations(sources) {\n  if (!Array.isArray(sources)) return \"No sources to format\";\n  \n  return sources.map((source, index) => \n    `[${index + 1}] ${source.title || 'Untitled'} - ${source.url || 'No URL'}`\n  ).join('\\n');\n}\n\nfunction analyzeContentStructure(content) {\n  const lines = content.split('\\n');\n  const headings = lines.filter(line => line.startsWith('#') || line.match(/^\\d+\\./));\n  const paragraphs = content.split('\\n\\n').length;\n  \n  return {\n    has_headings: headings.length > 0,\n    heading_count: headings.length,\n    paragraph_count: paragraphs,\n    word_count: content.split(' ').length,\n    structure_score: calculateStructureScore(headings.length, paragraphs)\n  };\n}\n\nfunction extractKeyPoints(content) {\n  const sentences = content.split('.').filter(s => s.trim().length > 20);\n  const keyPoints = [];\n  \n  for (const sentence of sentences) {\n    if (sentence.includes('important') || sentence.includes('key') || \n        sentence.includes('significant') || sentence.includes('crucial')) {\n      keyPoints.push(sentence.trim() + '.');\n    }\n  }\n  \n  return keyPoints.slice(0, 5);\n}\n\nfunction extractRecommendations(content) {\n  const recommendations = [];\n  const lines = content.split('\\n');\n  \n  for (const line of lines) {\n    if (line.toLowerCase().includes('recommend') || \n        line.toLowerCase().includes('suggest') ||\n        line.toLowerCase().includes('should')) {\n      recommendations.push(line.trim());\n    }\n  }\n  \n  return recommendations.slice(0, 5);\n}\n\nfunction extractCitedSources(content, researchData) {\n  const citations = [];\n  \n  if (researchData.sources) {\n    for (const source of researchData.sources) {\n      if (content.includes(source.title) || content.includes(source.url)) {\n        citations.push(source);\n      }\n    }\n  }\n  \n  return citations;\n}\n\nfunction assessReadability(content) {\n  const words = content.split(' ').length;\n  const sentences = content.split('.').length;\n  const avgWordsPerSentence = words / sentences;\n  \n  let readabilityScore;\n  if (avgWordsPerSentence < 15) readabilityScore = 'easy';\n  else if (avgWordsPerSentence < 25) readabilityScore = 'moderate';\n  else readabilityScore = 'difficult';\n  \n  return {\n    word_count: words,\n    sentence_count: sentences,\n    avg_words_per_sentence: avgWordsPerSentence,\n    readability_level: readabilityScore\n  };\n}\n\nfunction assessCompleteness(content, query) {\n  const queryWords = query.toLowerCase().split(' ');\n  const contentLower = content.toLowerCase();\n  \n  const addressedWords = queryWords.filter(word => \n    word.length > 3 && contentLower.includes(word)\n  );\n  \n  const completenessScore = addressedWords.length / queryWords.length;\n  \n  return {\n    query_coverage: completenessScore,\n    addressed_concepts: addressedWords.length,\n    total_concepts: queryWords.length,\n    completeness_level: completenessScore > 0.7 ? 'high' : completenessScore > 0.4 ? 'medium' : 'low'\n  };\n}\n\nfunction identifyEngagementElements(content) {\n  const elements = {\n    questions: (content.match(/\\?/g) || []).length,\n    examples: (content.match(/for example|such as|like/gi) || []).length,\n    lists: (content.match(/\\n\\s*[-*]|\\n\\s*\\d+\\./g) || []).length,\n    emphasis: (content.match(/\\*\\*.*?\\*\\*|__.*?__|\\*.*?\\*/g) || []).length\n  };\n  \n  elements.engagement_score = Object.values(elements).reduce((sum, val) => sum + val, 0) / 10;\n  \n  return elements;\n}\n\nfunction calculateStructureScore(headings, paragraphs) {\n  let score = 0;\n  if (headings > 0) score += 0.3;\n  if (paragraphs > 2) score += 0.3;\n  if (headings > 2) score += 0.2;\n  if (paragraphs > 5) score += 0.2;\n  return Math.min(1.0, score);\n}\n\nfunction calculateContentMetrics(enhancedContent) {\n  return {\n    structure_quality: enhancedContent.structure.structure_score,\n    readability_score: enhancedContent.readability.readability_level === 'easy' ? 0.9 : \n                      enhancedContent.readability.readability_level === 'moderate' ? 0.7 : 0.5,\n    completeness_score: enhancedContent.completeness.query_coverage,\n    engagement_score: enhancedContent.engagement_elements.engagement_score,\n    citation_count: enhancedContent.sources_cited.length,\n    recommendation_count: enhancedContent.recommendations.length\n  };\n}\n\nfunction calculateQualityScore(enhancedContent) {\n  const metrics = calculateContentMetrics(enhancedContent);\n  \n  const weights = {\n    structure_quality: 0.2,\n    readability_score: 0.25,\n    completeness_score: 0.3,\n    engagement_score: 0.15,\n    citation_quality: 0.1\n  };\n  \n  const citationQuality = Math.min(1.0, metrics.citation_count * 0.2);\n  \n  const qualityScore = \n    metrics.structure_quality * weights.structure_quality +\n    metrics.readability_score * weights.readability_score +\n    metrics.completeness_score * weights.completeness_score +\n    metrics.engagement_score * weights.engagement_score +\n    citationQuality * weights.citation_quality;\n  \n  return Math.min(0.95, Math.max(0.1, qualityScore));\n}\n\nfunction determineCreativeNextActions(enhancedContent) {\n  const actions = [];\n  \n  if (enhancedContent.completeness.completeness_level === 'low') {\n    actions.push({\n      action: \"content_expansion\",\n      priority: \"high\",\n      description: \"Content completeness is low - additional information needed\"\n    });\n  }\n  \n  if (enhancedContent.sources_cited.length === 0) {\n    actions.push({\n      action: \"source_verification\",\n      priority: \"medium\",\n      description: \"No sources cited - verification recommended\"\n    });\n  }\n  \n  if (enhancedContent.engagement_elements.engagement_score < 0.3) {\n    actions.push({\n      action: \"engagement_enhancement\",\n      priority: \"low\",\n      description: \"Low engagement elements - consider adding examples or questions\"\n    });\n  }\n  \n  actions.push({\n    action: \"response_delivery\",\n    priority: \"normal\",\n    description: \"Creative synthesis complete - ready for delivery\"\n  });\n  \n  return actions;\n}\n\nfunction generateCreativeId() {\n  return `creative_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n// Execute and return\nreturn await executeCreativeAgent();"
      },
      "type": "@n8n/n8n-nodes-langchain.code",
      "typeVersion": 1,
      "position": [360, 304],
      "id": "langchain-creative",
      "name": "Creative Agent"
    },
    {
      "parameters": {
        "queue": "={{ $json.routing.queue }}",
        "options": {
          "priority": "={{ $json.routing.priority }}"
        }
      },
      "id": "rabbitmq-publish",
      "name": "RabbitMQ Publish",
      "type": "n8n-nodes-base.rabbitmq",
      "typeVersion": 1,
      "position": [560, 304]
    },
    {
      "parameters": {
        "query": "={{ $json.neo4j_context.cypher }}",
        "additionalFields": {}
      },
      "id": "neo4j-write",
      "name": "Neo4j Write",
      "type": "n8n-nodes-base.neo4j",
      "typeVersion": 1,
      "position": [760, 304]
    },
    {
      "parameters": {
        "operation": "insert",
        "table": "creative_responses",
        "columns": "orchestration_id, session_id, query, final_response, quality_score, timestamp",
        "values": "={{ $json.creative_report.orchestration_id }}, {{ $json.creative_report.session_id }}, {{ $json.creative_report.query }}, {{ $json.creative_report.creative_output.final_response }}, {{ $json.creative_report.quality_score }}, {{ $json.creative_report.timestamp }}"
      },
      "id": "postgres-memory",
      "name": "PostgreSQL Memory",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [960, 304]
    }
  ],
  "pinData": {},
  "connections": {
    "RabbitMQ Consumer": {
      "main": [
        [
          {
            "node": "Creative Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Creative Agent": {
      "main": [
        [
          {
            "node": "RabbitMQ Publish",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RabbitMQ Publish": {
      "main": [
        [
          {
            "node": "Neo4j Write",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Neo4j Write": {
      "main": [
        [
          {
            "node": "PostgreSQL Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  }
}
