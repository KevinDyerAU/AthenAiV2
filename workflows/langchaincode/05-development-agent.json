{
  "name": "Development Agent",
  "nodes": [
    {
      "parameters": {
        "queue": "development_tasks",
        "options": {}
      },
      "id": "rabbitmq-consume",
      "name": "RabbitMQ Consumer",
      "type": "n8n-nodes-base.rabbitmqTrigger",
      "typeVersion": 1,
      "position": [160, 304]
    },
    {
      "parameters": {
        "jsCode": "// Development Agent - Production Implementation\nconst { ChatOpenAI } = require(\"@langchain/openai\");\nconst { AgentExecutor, createOpenAIFunctionsAgent } = require(\"langchain/agents\");\nconst { DynamicTool } = require(\"@langchain/core/tools\");\nconst { PromptTemplate } = require(\"@langchain/core/prompts\");\n\n// Initialize LangSmith tracing\nprocess.env.LANGCHAIN_TRACING_V2 = \"true\";\nprocess.env.LANGCHAIN_PROJECT = process.env.LANGCHAIN_PROJECT || \"athenai-development-agent\";\nprocess.env.LANGCHAIN_ENDPOINT = process.env.LANGCHAIN_ENDPOINT || \"https://api.smith.langchain.com\";\n\nasync function executeDevelopmentAgent() {\n  try {\n    const inputData = $json;\n    const taskData = inputData.task || inputData;\n    const requirements = taskData.requirements || taskData.query || taskData.original_message;\n    const sessionId = taskData.session_id || 'default_session';\n    const orchestrationId = taskData.orchestration_id || 'default_orchestration';\n    \n    if (!requirements) {\n      throw new Error('Development requirements are required');\n    }\n\n    // Initialize OpenAI\n    const llm = new ChatOpenAI({\n      modelName: \"gpt-4\",\n      temperature: 0.2,\n      openAIApiKey: $credentials.openAi?.apiKey || process.env.OPENAI_API_KEY,\n      tags: [\"development-agent\", \"athenai\"]\n    });\n\n    // Initialize development tools\n    const tools = await initializeDevelopmentTools();\n\n    // Create development prompt\n    const developmentPrompt = PromptTemplate.fromTemplate(`\nYou are a Development Agent specialized in software development, code generation, and technical solutions.\n\nDevelopment Requirements: {requirements}\nSession ID: {sessionId}\nOrchestration ID: {orchestrationId}\n\nYour task:\n1. Analyze the development requirements\n2. Design appropriate software architecture\n3. Generate clean, maintainable code\n4. Provide implementation guidelines\n5. Include testing strategies\n6. Document the solution thoroughly\n\nAvailable tools: {tools}\n\nProvide a comprehensive development solution with:\n- Architecture Design\n- Code Implementation\n- Testing Strategy\n- Documentation\n- Deployment Guidelines\n- Best Practices\n\nRequirements: {requirements}\n`);\n\n    // Create agent\n    const agent = await createOpenAIFunctionsAgent({\n      llm,\n      tools,\n      prompt: developmentPrompt\n    });\n\n    const agentExecutor = new AgentExecutor({\n      agent,\n      tools,\n      verbose: true,\n      maxIterations: 8\n    });\n\n    // Execute development\n    const developmentResult = await agentExecutor.invoke({\n      requirements: requirements,\n      sessionId: sessionId,\n      orchestrationId: orchestrationId,\n      tools: tools.map(t => t.name).join(\", \")\n    });\n\n    // Process development output\n    const structuredSolution = await processDevelopmentOutput(developmentResult, requirements);\n    const developmentMetrics = calculateDevelopmentMetrics(structuredSolution);\n\n    // Create development report\n    const developmentReport = {\n      orchestration_id: orchestrationId,\n      session_id: sessionId,\n      agent_type: \"development\",\n      requirements: requirements,\n      solution: structuredSolution,\n      metrics: developmentMetrics,\n      quality_score: calculateCodeQuality(structuredSolution),\n      timestamp: new Date().toISOString(),\n      status: \"completed\"\n    };\n\n    return [{\n      json: {\n        development_report: developmentReport,\n        deliverables: structuredSolution.deliverables,\n        next_actions: determineDevelopmentNextActions(structuredSolution),\n        neo4j_context: {\n          write: true,\n          cypher: `MERGE (s:Session {id: '${sessionId}'}) MERGE (o:Orchestration {id: '${orchestrationId}'}) MERGE (d:DevelopmentSolution {id: '${generateDevelopmentId()}', requirements: '${requirements.replace(/'/g, \"\\\\'\"))}', timestamp: datetime(), quality: ${developmentReport.quality_score}}) MERGE (s)-[:HAS_ORCHESTRATION]->(o) MERGE (o)-[:GENERATED_SOLUTION]->(d)`\n        },\n        memory: {\n          upsert: true,\n          keys: [\"requirements\", \"solution\", \"quality_score\", \"timestamp\"]\n        },\n        routing: {\n          queue: \"qa_tasks\",\n          priority: \"normal\"\n        }\n      }\n    }];\n\n  } catch (error) {\n    return [{\n      json: {\n        error: error.message,\n        agent_type: \"development\",\n        status: \"failed\",\n        timestamp: new Date().toISOString(),\n        fallback_solution: {\n          message: \"Development agent encountered an error. Manual development may be required.\",\n          recommendations: [\n            \"Review requirements for clarity\",\n            \"Check technical feasibility\",\n            \"Consider alternative approaches\"\n          ]\n        }\n      }\n    }];\n  }\n}\n\n// Initialize development tools\nasync function initializeDevelopmentTools() {\n  return [\n    new DynamicTool({\n      name: \"code_generator\",\n      description: \"Generate code based on specifications\",\n      func: async (spec) => {\n        try {\n          const code = generateCode(spec);\n          return code;\n        } catch (error) {\n          return `Code generation error: ${error.message}`;\n        }\n      }\n    }),\n    new DynamicTool({\n      name: \"architecture_designer\",\n      description: \"Design software architecture and system components\",\n      func: async (requirements) => {\n        try {\n          const architecture = designArchitecture(requirements);\n          return JSON.stringify(architecture, null, 2);\n        } catch (error) {\n          return `Architecture design error: ${error.message}`;\n        }\n      }\n    }),\n    new DynamicTool({\n      name: \"test_generator\",\n      description: \"Generate unit tests and testing strategies\",\n      func: async (codeSpec) => {\n        try {\n          const tests = generateTests(codeSpec);\n          return tests;\n        } catch (error) {\n          return `Test generation error: ${error.message}`;\n        }\n      }\n    }),\n    new DynamicTool({\n      name: \"documentation_generator\",\n      description: \"Generate technical documentation\",\n      func: async (solution) => {\n        try {\n          const docs = generateDocumentation(solution);\n          return docs;\n        } catch (error) {\n          return `Documentation generation error: ${error.message}`;\n        }\n      }\n    }),\n    new DynamicTool({\n      name: \"dependency_analyzer\",\n      description: \"Analyze and recommend dependencies\",\n      func: async (requirements) => {\n        try {\n          const dependencies = analyzeDependencies(requirements);\n          return JSON.stringify(dependencies, null, 2);\n        } catch (error) {\n          return `Dependency analysis error: ${error.message}`;\n        }\n      }\n    })\n  ];\n}\n\n// Process development output\nasync function processDevelopmentOutput(developmentResult, requirements) {\n  const output = developmentResult.output || \"\";\n  \n  return {\n    architecture: extractArchitecture(output),\n    code_components: extractCodeComponents(output),\n    testing_strategy: extractTestingStrategy(output),\n    documentation: extractDocumentation(output),\n    deployment_plan: extractDeploymentPlan(output),\n    dependencies: extractDependencies(output),\n    deliverables: generateDeliverables(output, requirements),\n    implementation_timeline: estimateTimeline(output),\n    technical_considerations: extractTechnicalConsiderations(output)\n  };\n}\n\n// Code generation functions\nfunction generateCode(spec) {\n  const language = detectLanguage(spec);\n  const framework = detectFramework(spec);\n  \n  const codeTemplate = getCodeTemplate(language, framework);\n  const customCode = generateCustomCode(spec, language);\n  \n  return `// Generated ${language} code\\n${codeTemplate}\\n\\n${customCode}`;\n}\n\nfunction designArchitecture(requirements) {\n  const complexity = assessComplexity(requirements);\n  const patterns = recommendPatterns(requirements);\n  \n  return {\n    architecture_type: determineArchitectureType(complexity),\n    components: identifyComponents(requirements),\n    patterns: patterns,\n    data_flow: designDataFlow(requirements),\n    scalability: assessScalability(requirements),\n    security_considerations: identifySecurityNeeds(requirements)\n  };\n}\n\nfunction generateTests(codeSpec) {\n  const testFramework = recommendTestFramework(codeSpec);\n  const testCases = generateTestCases(codeSpec);\n  \n  return `// Generated test suite using ${testFramework}\\n${testCases}`;\n}\n\nfunction generateDocumentation(solution) {\n  return `# Technical Documentation\\n\\n## Overview\\n${solution}\\n\\n## Architecture\\n\\n## Implementation Guide\\n\\n## API Reference\\n\\n## Deployment Instructions`;\n}\n\nfunction analyzeDependencies(requirements) {\n  const language = detectLanguage(requirements);\n  const dependencies = recommendDependencies(language, requirements);\n  \n  return {\n    language: language,\n    runtime_dependencies: dependencies.runtime,\n    development_dependencies: dependencies.dev,\n    package_manager: getPackageManager(language),\n    version_constraints: dependencies.versions\n  };\n}\n\n// Helper functions\nfunction detectLanguage(spec) {\n  const specLower = spec.toLowerCase();\n  \n  if (specLower.includes('python') || specLower.includes('django') || specLower.includes('flask')) return 'python';\n  if (specLower.includes('javascript') || specLower.includes('node') || specLower.includes('react')) return 'javascript';\n  if (specLower.includes('java') || specLower.includes('spring')) return 'java';\n  if (specLower.includes('c#') || specLower.includes('.net')) return 'csharp';\n  if (specLower.includes('go') || specLower.includes('golang')) return 'go';\n  \n  return 'javascript'; // Default\n}\n\nfunction detectFramework(spec) {\n  const specLower = spec.toLowerCase();\n  \n  if (specLower.includes('react')) return 'react';\n  if (specLower.includes('vue')) return 'vue';\n  if (specLower.includes('angular')) return 'angular';\n  if (specLower.includes('express')) return 'express';\n  if (specLower.includes('django')) return 'django';\n  if (specLower.includes('flask')) return 'flask';\n  \n  return 'express'; // Default\n}\n\nfunction getCodeTemplate(language, framework) {\n  const templates = {\n    javascript: {\n      express: `const express = require('express');\\nconst app = express();\\n\\napp.use(express.json());\\n\\n// Routes will be added here\\n\\nconst PORT = process.env.PORT || 3000;\\napp.listen(PORT, () => console.log(\\`Server running on port \\${PORT}\\`));`,\n      react: `import React from 'react';\\nimport ReactDOM from 'react-dom';\\n\\nfunction App() {\\n  return (\\n    <div className=\"App\">\\n      <h1>Hello World</h1>\\n    </div>\\n  );\\n}\\n\\nReactDOM.render(<App />, document.getElementById('root'));`\n    },\n    python: {\n      flask: `from flask import Flask, request, jsonify\\n\\napp = Flask(__name__)\\n\\n@app.route('/')\\ndef hello():\\n    return 'Hello World!'\\n\\nif __name__ == '__main__':\\n    app.run(debug=True)`,\n      django: `from django.http import HttpResponse\\nfrom django.shortcuts import render\\n\\ndef index(request):\\n    return HttpResponse(\"Hello World!\")`\n    }\n  };\n  \n  return templates[language]?.[framework] || '// Code template not available';\n}\n\nfunction generateCustomCode(spec, language) {\n  // Generate custom code based on specifications\n  return `// Custom implementation for: ${spec}\\n// TODO: Implement specific functionality`;\n}\n\nfunction assessComplexity(requirements) {\n  const indicators = {\n    length: requirements.length,\n    technical_terms: countTechnicalTerms(requirements),\n    integration_points: countIntegrations(requirements),\n    user_types: countUserTypes(requirements)\n  };\n  \n  let complexity = 'low';\n  if (indicators.technical_terms > 5 || indicators.integration_points > 2) complexity = 'medium';\n  if (indicators.technical_terms > 10 || indicators.integration_points > 5) complexity = 'high';\n  \n  return complexity;\n}\n\nfunction recommendPatterns(requirements) {\n  const patterns = [];\n  const reqLower = requirements.toLowerCase();\n  \n  if (reqLower.includes('api') || reqLower.includes('service')) patterns.push('MVC', 'Repository');\n  if (reqLower.includes('real-time') || reqLower.includes('websocket')) patterns.push('Observer', 'Publisher-Subscriber');\n  if (reqLower.includes('database') || reqLower.includes('data')) patterns.push('Repository', 'Unit of Work');\n  \n  return patterns;\n}\n\nfunction determineArchitectureType(complexity) {\n  switch (complexity) {\n    case 'low': return 'monolithic';\n    case 'medium': return 'modular-monolith';\n    case 'high': return 'microservices';\n    default: return 'monolithic';\n  }\n}\n\nfunction identifyComponents(requirements) {\n  const components = ['core', 'api', 'database'];\n  const reqLower = requirements.toLowerCase();\n  \n  if (reqLower.includes('auth') || reqLower.includes('login')) components.push('authentication');\n  if (reqLower.includes('ui') || reqLower.includes('frontend')) components.push('frontend');\n  if (reqLower.includes('notification')) components.push('notification-service');\n  if (reqLower.includes('file') || reqLower.includes('upload')) components.push('file-service');\n  \n  return components;\n}\n\nfunction designDataFlow(requirements) {\n  return {\n    input_sources: ['user-interface', 'api-endpoints'],\n    processing_layers: ['validation', 'business-logic', 'data-access'],\n    output_destinations: ['database', 'response', 'notifications'],\n    flow_type: 'synchronous' // Could be determined from requirements\n  };\n}\n\nfunction assessScalability(requirements) {\n  return {\n    expected_load: 'medium',\n    scaling_strategy: 'horizontal',\n    bottlenecks: ['database', 'api-rate-limits'],\n    optimization_opportunities: ['caching', 'connection-pooling']\n  };\n}\n\nfunction identifySecurityNeeds(requirements) {\n  const needs = ['input-validation', 'error-handling'];\n  const reqLower = requirements.toLowerCase();\n  \n  if (reqLower.includes('auth') || reqLower.includes('user')) needs.push('authentication', 'authorization');\n  if (reqLower.includes('data') || reqLower.includes('personal')) needs.push('data-encryption', 'privacy-compliance');\n  if (reqLower.includes('api')) needs.push('rate-limiting', 'cors-configuration');\n  \n  return needs;\n}\n\nfunction recommendTestFramework(codeSpec) {\n  const language = detectLanguage(codeSpec);\n  \n  const frameworks = {\n    javascript: 'Jest',\n    python: 'pytest',\n    java: 'JUnit',\n    csharp: 'NUnit',\n    go: 'testing'\n  };\n  \n  return frameworks[language] || 'Jest';\n}\n\nfunction generateTestCases(codeSpec) {\n  return `describe('Generated Test Suite', () => {\\n  test('should pass basic functionality test', () => {\\n    // Test implementation\\n    expect(true).toBe(true);\\n  });\\n\\n  test('should handle edge cases', () => {\\n    // Edge case testing\\n  });\\n});`;\n}\n\nfunction recommendDependencies(language, requirements) {\n  const deps = {\n    javascript: {\n      runtime: ['express', 'cors', 'helmet'],\n      dev: ['jest', 'nodemon', 'eslint'],\n      versions: { node: '>=14.0.0' }\n    },\n    python: {\n      runtime: ['flask', 'requests', 'python-dotenv'],\n      dev: ['pytest', 'black', 'flake8'],\n      versions: { python: '>=3.8' }\n    }\n  };\n  \n  return deps[language] || deps.javascript;\n}\n\nfunction getPackageManager(language) {\n  const managers = {\n    javascript: 'npm',\n    python: 'pip',\n    java: 'maven',\n    csharp: 'nuget',\n    go: 'go mod'\n  };\n  \n  return managers[language] || 'npm';\n}\n\nfunction countTechnicalTerms(text) {\n  const terms = ['api', 'database', 'service', 'authentication', 'authorization', 'microservice', 'framework', 'library'];\n  return terms.filter(term => text.toLowerCase().includes(term)).length;\n}\n\nfunction countIntegrations(text) {\n  const integrations = ['integrate', 'connect', 'api', 'service', 'third-party', 'external'];\n  return integrations.filter(term => text.toLowerCase().includes(term)).length;\n}\n\nfunction countUserTypes(text) {\n  const userTypes = ['admin', 'user', 'customer', 'client', 'manager', 'employee'];\n  return userTypes.filter(type => text.toLowerCase().includes(type)).length;\n}\n\n// Extract functions for processing output\nfunction extractArchitecture(output) {\n  return {\n    type: 'modular',\n    components: ['frontend', 'backend', 'database'],\n    patterns: ['MVC', 'Repository']\n  };\n}\n\nfunction extractCodeComponents(output) {\n  return {\n    modules: ['core', 'api', 'utils'],\n    classes: ['Controller', 'Service', 'Repository'],\n    functions: ['create', 'read', 'update', 'delete']\n  };\n}\n\nfunction extractTestingStrategy(output) {\n  return {\n    unit_tests: true,\n    integration_tests: true,\n    e2e_tests: false,\n    coverage_target: 80\n  };\n}\n\nfunction extractDocumentation(output) {\n  return {\n    api_docs: true,\n    code_comments: true,\n    readme: true,\n    deployment_guide: true\n  };\n}\n\nfunction extractDeploymentPlan(output) {\n  return {\n    environment: 'docker',\n    ci_cd: true,\n    monitoring: true,\n    backup_strategy: true\n  };\n}\n\nfunction extractDependencies(output) {\n  return {\n    runtime: ['express', 'cors'],\n    development: ['jest', 'nodemon'],\n    system: ['node', 'npm']\n  };\n}\n\nfunction generateDeliverables(output, requirements) {\n  return {\n    source_code: 'Complete application source code',\n    documentation: 'Technical and user documentation',\n    tests: 'Comprehensive test suite',\n    deployment_scripts: 'Docker and deployment configurations',\n    api_specification: 'OpenAPI/Swagger documentation'\n  };\n}\n\nfunction estimateTimeline(output) {\n  return {\n    planning: '1-2 days',\n    development: '1-2 weeks',\n    testing: '2-3 days',\n    deployment: '1 day',\n    total_estimate: '2-3 weeks'\n  };\n}\n\nfunction extractTechnicalConsiderations(output) {\n  return {\n    performance: 'Optimize for response time under 200ms',\n    security: 'Implement authentication and input validation',\n    scalability: 'Design for horizontal scaling',\n    maintainability: 'Follow coding standards and documentation'\n  };\n}\n\nfunction calculateDevelopmentMetrics(solution) {\n  return {\n    component_count: solution.code_components ? Object.keys(solution.code_components).length : 0,\n    architecture_complexity: solution.architecture ? solution.architecture.components.length : 0,\n    testing_coverage: solution.testing_strategy ? solution.testing_strategy.coverage_target : 0,\n    documentation_completeness: calculateDocCompleteness(solution.documentation),\n    dependency_count: solution.dependencies ? Object.values(solution.dependencies).flat().length : 0\n  };\n}\n\nfunction calculateDocCompleteness(docs) {\n  if (!docs) return 0;\n  const docTypes = ['api_docs', 'code_comments', 'readme', 'deployment_guide'];\n  const completed = docTypes.filter(type => docs[type]).length;\n  return completed / docTypes.length;\n}\n\nfunction calculateCodeQuality(solution) {\n  let score = 0.5; // Base score\n  \n  if (solution.architecture && solution.architecture.components.length > 2) score += 0.1;\n  if (solution.testing_strategy && solution.testing_strategy.coverage_target >= 80) score += 0.2;\n  if (solution.documentation && calculateDocCompleteness(solution.documentation) > 0.7) score += 0.1;\n  if (solution.technical_considerations) score += 0.1;\n  \n  return Math.min(0.95, Math.max(0.1, score));\n}\n\nfunction determineDevelopmentNextActions(solution) {\n  const actions = [];\n  \n  if (!solution.testing_strategy || solution.testing_strategy.coverage_target < 70) {\n    actions.push({\n      action: \"improve_testing\",\n      priority: \"high\",\n      description: \"Testing coverage is insufficient - enhance test suite\"\n    });\n  }\n  \n  if (!solution.documentation || calculateDocCompleteness(solution.documentation) < 0.6) {\n    actions.push({\n      action: \"complete_documentation\",\n      priority: \"medium\",\n      description: \"Documentation is incomplete - add missing sections\"\n    });\n  }\n  \n  actions.push({\n    action: \"quality_assurance\",\n    priority: \"normal\",\n    description: \"Development complete - ready for QA review\"\n  });\n  \n  return actions;\n}\n\nfunction generateDevelopmentId() {\n  return `dev_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n// Execute and return\nreturn await executeDevelopmentAgent();"
      },
      "type": "@n8n/n8n-nodes-langchain.code",
      "typeVersion": 1,
      "position": [360, 304],
      "id": "langchain-development",
      "name": "Development Agent"
    },
    {
      "parameters": {
        "queue": "={{ $json.routing.queue }}",
        "options": {
          "priority": "={{ $json.routing.priority }}"
        }
      },
      "id": "rabbitmq-publish",
      "name": "RabbitMQ Publish",
      "type": "n8n-nodes-base.rabbitmq",
      "typeVersion": 1,
      "position": [560, 304]
    },
    {
      "parameters": {
        "query": "={{ $json.neo4j_context.cypher }}",
        "additionalFields": {}
      },
      "id": "neo4j-write",
      "name": "Neo4j Write",
      "type": "n8n-nodes-base.neo4j",
      "typeVersion": 1,
      "position": [760, 304]
    },
    {
      "parameters": {
        "operation": "insert",
        "table": "development_solutions",
        "columns": "orchestration_id, session_id, requirements, solution, quality_score, timestamp",
        "values": "={{ $json.development_report.orchestration_id }}, {{ $json.development_report.session_id }}, {{ $json.development_report.requirements }}, {{ JSON.stringify($json.development_report.solution) }}, {{ $json.development_report.quality_score }}, {{ $json.development_report.timestamp }}"
      },
      "id": "postgres-memory",
      "name": "PostgreSQL Memory",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [960, 304]
    }
  ],
  "pinData": {},
  "connections": {
    "RabbitMQ Consumer": {
      "main": [
        [
          {
            "node": "Development Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Development Agent": {
      "main": [
        [
          {
            "node": "RabbitMQ Publish",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RabbitMQ Publish": {
      "main": [
        [
          {
            "node": "Neo4j Write",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Neo4j Write": {
      "main": [
        [
          {
            "node": "PostgreSQL Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  }
}
